# -*- coding: utf-8 -*-
"""e

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1NdVcBvX8pQQL4QPFo7RS6srfWiPpkHpE
"""

# predictor.py

import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_squared_error, r2_score
from sklearn.impute import SimpleImputer
from sklearn.preprocessing import OneHotEncoder
from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline
from xgboost import XGBRegressor
from math import sqrt

def predict_cardiovascular_disease_value(state_code):
    """
    Predicts the cardiovascular disease indicator for a given state using the XGBoost model.

    Parameters:
    state_code (str): The two-letter abbreviation of the state.

    Returns:
    dict: A dictionary containing the predicted value, RMSE, MSE, and R2 score.
    """
    # Data loading and preprocessing
    url = "https://storage.googleapis.com/mbcc/datasets/us_chronic_disease_indicators.csv"
    df = pd.read_csv(url)
    df = df.drop('locationdesc', axis=1)
    df = df[df['datavaluetype'] == 'Number']
    df = df[df['topic'] == "Cardiovascular Disease"]
    df = df.drop(['datavalueunit', 'highconfidencelimit', 'lowconfidencelimit'], axis=1)
    df = pd.get_dummies(df, columns=['locationabbr'])

    if all(df['yearstart'] == df['yearend']):
        df = df.drop('yearend', axis=1)

    # Feature selection
    categorical_features = ['datasource', 'question', 'stratificationcategory1', 'stratification1',
                            'topicid', 'questionid', 'datavaluetypeid', 'stratificationcategoryid1',
                            'stratificationid1', 'locationabbr']
    numerical_features = ['yearstart']
    target_variable = 'datavalue'

    # Mapping state codes to digits
    state_to_digit = { ... }  # Include the full mapping here

    df['location_2digit'] = df['locationabbr'].map(state_to_digit)
    df['location_2digit'] = pd.to_numeric(df['location_2digit'])

    # Data transformation
    X = df[categorical_features + numerical_features + ['location_2digit']]
    y = df[target_variable]

    numerical_transformer = SimpleImputer(strategy='mean')
    categorical_transformer = Pipeline(steps=[
        ('imputer', SimpleImputer(strategy='most_frequent')),
        ('onehot', OneHotEncoder(handle_unknown='ignore'))
    ])
    preprocessor = ColumnTransformer(
        transformers=[
            ('num', numerical_transformer, numerical_features),
            ('cat', categorical_transformer, categorical_features)
        ])
    X_transformed = preprocessor.fit_transform(X)

    # Model training
    X_train, X_test, y_train, y_test = train_test_split(X_transformed, y, test_size=0.2, random_state=42)
    xgb_model = XGBRegressor(random_state=42)
    xgb_model.fit(X_train, y_train)

    # Model evaluation
    xgb_predictions = xgb_model.predict(X_test)
    xgb_mse = mean_squared_error(y_test, xgb_predictions)
    xgb_rmse = sqrt(xgb_mse)
    xgb_r2 = r2_score(y_test, xgb_predictions)

    # Prediction for the specified state
    template_data = pd.DataFrame([{
        'yearstart': 2023,
        'datasource': 'common', 'question': 'common', 'stratificationcategory1': 'common',
        'stratification1': 'common', 'topicid': 'common', 'questionid': 'common',
        'datavaluetypeid': 'common', 'stratificationcategoryid1': 'common',
        'stratificationid1': 'common', 'locationabbr': state_code
    }])
    template_data['location_2digit'] = template_data['locationabbr'].map(state_to_digit)
    template_data['location_2digit'] = pd.to_numeric(template_data['location_2digit'])
    X_template_transformed = preprocessor.transform(template_data)

    future_prediction = xgb_model.predict(X_template_transformed)[0]

    # Returning the results
    return {
        "predicted_value": future_prediction,
        "rmse": xgb_rmse,
        "mse": xgb_mse,
        "r2_score": xgb_r2
    }